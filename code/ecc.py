# -*- coding: utf-8 -*-
"""Tutorial_6_ECC.ipynb

Tutorial: Elliptic Curve Cryptography - Key Generation

**_Proof of work_** is the unique contribution to the bitcoin protocol that achieves two aims:
1. allows nodes to vote with their hashpower to achieve consensus
2. keeps the network secure by aligning incentives.
------------------------------------------
@file: ecc.py
@updated: August 08, 2020
@author: Jeff Nijsse
------------------------------------------

Automatically generated by Colaboratory.

# Introduction
This [Jupyter](https://jupyter.org/) notebook can be run using [colab.research.google.com](https://colab.research.google.com). See [here](https://colab.research.google.com/notebooks/intro.ipynb) for an intro. Alternatively this can be downloaded and run locally with [Anaconda](https://docs.anaconda.com/anaconda/navigator/). Jupyter and Anaconda should be installed in all AUT engineering and computer science labs. I recommend using the Goolge web-interface.

The benefit of using Jupyter is that code snippets can be run live (Python is running in the background).

The version on Github is static; markdown is rendered but code cannot be executed. All code can be copied and pasted into your favourite text editor or IDE and *should* run with Python 3.x ;)

You are encouraged to use any programming language you feel comfortable with, this is simply an example using Python (and Jupyter is designed for Python demonstrations).

See lab instructions at the bottom of the page to install the dependencies in the computer lab. This is not necessary if using the Colab (web) interface.
***
Press ```shift+enter``` to run the individual code cell. Or mouse over and click the play button. See the ```Runtime``` menu for all options.

You may have to wait for the environment to initialize if this is the first time. There is a status bar above.

The out put will appear directly below the code block.
***

# Tutorial: Creating a Bitcoin address from an asymmetric public-private key pair

Bitcoin and many other cryptocurrencies including those forked from bitcoin use elliptic curve cryptography to generate key pairs and sign transactions. Keep in mind the transactions themselves are not encrypted -- the data is public -- but private keys must be kept secure. 

In this tutorial we will use a cryptographic library with built-in support for symmetric & asymmetric schemes, and digital signature algorithms. This will allow us to generate a key pair which we will then convert into a standard Bitcoin address.

### Precondition: Using standard Fernet
We will need to install the ```cryptography``` library as it is not part of standard Colab.

Remember: Press ```shift+enter``` to run the individual code cell. Or mouse over and click the play button. See the ```Runtime``` menu for all options.
"""

pip install cryptography

"""Successful output should say:
```Successfully installed cryptography-3.0```

[Fernet](https://cryptography.io/en/latest/fernet/) is the name of python's cryptography package for symmetric encryption. It is also a bitter Italian liqueur. Jeff is not sure how the two are related.
"""

from cryptography.fernet import Fernet
key = Fernet.generate_key()
print(key)

"""Recall the `b'` means its a byte object. Generate the key a second time. (```Shift+Enter```) Did it change? Think about using the same code to generate keys, how can we (Fernet) ensure that keys are different every time?"""

#show a listing of available methods in the Fernet library
dir(Fernet)

"""Four of the bottom few methods may be useful: ```decrypt, encrypt, extract_timestamp, generate_key```. The ```..._at_time``` methods are for testing tokens that expire, for example receiving an email code that expires in ten minutes.

Fernet can be implemented as follows:
"""

#the 'suite' will be like a 'cryptography object' that we can encrypt/decrypt with
cipher_suite = Fernet(key)
cipher_text = cipher_suite.encrypt(b'we attack at dawn')
print('Plain Text: ')
print(cipher_text)

"""this message can be sent in the open or communicated freely. Upon receipt, we may want to decrypt it into a form that contains information."""

#when calling 'decrypt' the cipher_suite already has the 'key' we made
plain_text = cipher_suite.decrypt(cipher_text)
plain_text = plain_text.decode()
print('Plain Text: '+plain_text)

"""Usage: The object `cipher_text` can be sent/received without worrying about end-to-end encryption or eavesdroppers. The process or receiver at the other end needs the `key` generated above. Sending the key requires a *key exchange* method such as Diffie-Helmann so that it can't be intercepted. This is because it is a symmetric method of encryption; the key is used for both encryption and decryption.

Standard Fernet is prepackaged so that developers that can use it without needing detailed cryptographic knowledge. It is also "safer" (you will notice many warnings on the documentation page).

### Hazardous Materials
We want to generate keys that will work with the bitcoin network and so will need to dig into the workings of the library. Specifically we are looking for keys that work with the standard curve `secp256k1` which bitcoin was designed for.
"""

# backend provides access to a variety of helper methods
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
# 'ec' is elliptic curve cryptography library
from cryptography.hazmat.primitives.asymmetric import ec

"""Note that we're now in the `hazmat` section and have access to `asymmetric` functions"""

curve = ec.SECP256K1()
print(curve)

"""This `curve` contains all the details from http://www.secg.org/sec2-v2.pdf including the constants necessary for point generation. They are listed here for interest. If you were developing without this library (a new programming language for example) you would need to set the following parameteres:

```python
# large prime number
p = 2**256 - 2**32 - 2**9 - 2**8 - 2**7 - 2**6 - 2**4 - 1
# curve constants
a = 0
b = 7
# generator point; coordinates on the 'curve' (not really a curve)
g_x = 55066263022277343669578718895168534326250603453777594175500187360389116729240
g_y = 32670510020758816978083085130507043184471273380659243275938904335757337482424
# number of points in the field; n < p
n = 115792089237316195423570985008687907852837564279074904382605163141518161494337
h = 1
```

The curve has been loaded as `ec`, now to generate a key which is a point on the curve (x,y).
"""

private_key = ec.generate_private_key(curve,default_backend())
print(private_key)

"""This is very clearly a `...PrivateKey object` such that you can't accidentally dump the key or read it. Here we have dipped into the [openSSL](https://en.wikipedia.org/wiki/OpenSSL) standards; you may be familiar with these if you have taken a networking course. SSL is secure sockets layer and in this case is a broad term for network security.

Once you generate a private key, you can derive the public key by calling `public_key()`. Private key is first, then the public portion is derived from it.
"""

public_key = private_key.public_key()
print(public_key)

"""## Bitcoin addresses

To create a bitcoin address we need the key in a form we can manipulate (not just an object in memory). This is because the Bitcoin protocol uses a custom format for addresses.
"""

# view the private key (human readable) we must invoke serialization of the key object
from cryptography.hazmat.primitives import serialization
# create a serialized version of the private key (ks)
private_ks = private_key.private_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PrivateFormat.TraditionalOpenSSL,
    encryption_algorithm=serialization.NoEncryption())
# this is a byte object decoded into base64
print(private_ks.decode())

"""The key displayed above is in PEM (privacy enhanced mail) format which is a standard format for cryptographic objects like keys and signatures. In this format keys can be imported from files and exported, etc. If we were using a different scheme, say RSA, then the header tag would indicate `-----BEGIN RSA PRIVATE KEY-----`

And now the public key:
"""

public_ks =public_key.public_bytes(
    serialization.Encoding.PEM,
    serialization.PublicFormat.SubjectPublicKeyInfo)
print(public_ks.decode())

"""Notice that much of the public key is also part of the private key. This isn't surprising because the public key is derived from the private key. 

### Convert the public key to an address
Rather than use the base64 representation decoded from PEM, we will start with the point on the elliptic curve and convert this integer into a base58 address that can be used with the bitcoin network.

This process is decribed in (*Masting Bitcoin* by Antonopolous, 2017, pp64-70) and shown in the chart hosted [here](https://github.com/millecodex/COMP726/blob/master/img/btcAddress.PNG).
"""

# extract the x-coordinate of the ec public key (point)
x_coord = public_key.public_numbers()._x
print(x_coord)

"""This is a *verry* big number. This is what we want. This is a real point that could be used in practise; not just for demonstration."""

# convert to hex
pub_key_hex = hex(x_coord)
print(pub_key_hex)

# strip the first two characters "0x" signifying a hex number
pub_key_hex = pub_key_hex[2:]
print(pub_key_hex)

# append the prefix 03 indicating that the y-value was odd
# with this code, half the addresses should not validate
pub_key_hex = '03'+pub_key_hex
print(pub_key_hex)

"""Next, two hash functions are used. First `sha256` which has a 256 bit output, second as `ripemd160` which has a ...160 bit output."""

import hashlib
# hashed first as sha256, then as ripemd160 
temp = hashlib.sha256(pub_key_hex.encode())
pub_key_hash = hashlib.new('ripemd160',temp.digest()).digest()
print(pub_key_hash)

# prefix a zero byte for a bitcoin address
pub_key_hash = bytes.fromhex('00')+pub_key_hash
print(pub_key_hash)

"""Bitcoin base58 check encoding is pictured [here](https://github.com/millecodex/COMP726/blob/master/img/Base58check.PNG) (Antonopolous, 2017). Its not a typo, the `sha256` hash is run twice. This was a design decision and there is [debate](https://bitcoin.stackexchange.com/questions/9202/why-does-bitcoin-use-two-hash-functions-sha-256-and-ripemd-160-to-create-an-ad#9216) about the motivation behind this decision and whether it changes the security properties."""

# double sha256 hash and take the first 4 bytes as a checksum
dubhash = hashlib.sha256(hashlib.sha256(pub_key_hash).digest()).digest()
checksum = dubhash[:4]
pub_key_check = pub_key_hash + checksum
print(pub_key_check)

"""The final step is to convert to base58 which is a bitcoin specific encoding. A good exercise is to write your own base58 converter! Here, I'm importing one called base58. You might have to install the package=>`!pip install base58`"""

# now convert to base58 encoding
# may need the base58 package to be installed
import base58
key_b58 = base58.b58encode(pub_key_check)
btc_address = key_b58.decode()
print(btc_address)

"""Verify the address you made [here](http://lenschulwitz.com/base58).

---
# Summary

In this tutorial we have:<br>
 - used a cryptographic library to generate a symmetric key pair
 - accessed the elliptic curve module to generate a public-private key pair
 - converted an elliptic curve public point to a bitcoin address
 
What we have __not__ done is:<br>
 - investigate how private keys are generated by the system
 - verified our procedure works for all keys generated (see exercise)
 
Python libraries that this code depends on:
 - [cryptography](https://cryptography.io/en/latest/)
 - [base58](https://pypi.org/project/base58/)
 - [hashlib](https://docs.python.org/3/library/hashlib.html)

Elliptic Curve Standards [Documentation](http://www.secg.org/sec2-v2.pdf)

---
# Exercises

1. Copy and paste the keys generated above (```private_ks``` & ```public_ks```) into a text editor to compare them. Can you think of how to compress this public/private key pair?

2. Change the code in this notebook to handle **all** generated points on the curve. This notebook assumes the x-coordinate is odd and prepends `03` to the compressed format. See figure 4.7 in Antonopolous.

3. Write a script to generate multiple addresses. Why would you need multiple addresses? 

4. How many addresses are possible? If you write an address-generating script and leave it running, will you eventually generate everyone's bitcoin keys?

---
# <a id='install'>Lab Installation of pip and libraries</a>
###Install the python package installer - [PIP](https://pip.pypa.io/en/stable/installing/)

This will install pip on your local lab PC
1. Download [get-pip.py](https://bootstrap.pypa.io/get-pip.py) and save to `C:\Python37\`
2. Open a command prompt and navigate to `C:\Python37\`
3. type>> `python get-pip.py --proxy=http://cache.aut.ac.nz:3128`
4. you can now install packages using: `pip install packageName`

### Install the base58 package in Anaconda
If you are running the jupyter notebook it uses a different python interpreter found in its own install directory. This version of python already has `cryptography` installed, but you will need to add the `base58` encoder package.
1. Navigate to `C:\ProgramData\Anaconda\`
2. Type>> `python -m pip install base58 --proxy=http://cache.aut.ac.nz:3128`

### Check your jupyter environment
The following may be handy to determine what's going on within jupyter
```python
import sys
print(sys.version)
print(sys.executable)
```
"""